$date
    Feb  5, 2026  18:07:18
$end
$version
    TOOL:	xmsim(64)	24.03-s013
$end
$timescale
    1 ps
$end

$scope module tb $end
$var parameter 32 !    INT_W $end
$var parameter 32 "    FRAC_W $end
$var parameter 32 #    INST_W $end
$var parameter 32 $    DATA_W $end
$var reg       1 %    i_clk $end
$var reg       1 &    i_rst_n $end
$var reg       1 '    i_valid $end
$var reg      12 (    i_data_a [11:0] $end
$var reg      12 )    i_data_b [11:0] $end
$var reg       3 *    i_inst [2:0] $end
$var wire      1 +    o_valid  $end
$var wire     12 ,    o_data [11:0] $end
$var wire      1 -    o_overflow  $end
$var integer  32 .    i $end
$var integer  32 /    j $end
$var integer  32 0    error $end
$var reg      27 1    inst_idata[0] [26:0] $end
$var reg      27 2    inst_idata[1] [26:0] $end
$var reg      27 3    inst_idata[2] [26:0] $end
$var reg      27 4    inst_idata[3] [26:0] $end
$var reg      27 5    inst_idata[4] [26:0] $end
$var reg      13 6    inst_odata[0] [12:0] $end
$var reg      13 7    inst_odata[1] [12:0] $end
$var reg      13 8    inst_odata[2] [12:0] $end
$var reg      13 9    inst_odata[3] [12:0] $end
$var reg      13 :    inst_odata[4] [12:0] $end
$var reg      12 ;    test_inA [11:0] $end
$var reg      12 <    test_inB [11:0] $end
$var reg       3 =    test_inst [2:0] $end
$var reg       1 >    test_outO $end
$var reg      12 ?    test_outD [11:0] $end

$scope module u_alu $end
$var wire      1 @    i_clk  $end
$var wire      1 A    i_rst_n  $end
$var wire      1 B    i_valid  $end
$var wire     12 C    i_data_a [11:0] $end
$var wire     12 D    i_data_b [11:0] $end
$var wire      3 E    i_inst [2:0] $end
$var wire      1 +    o_valid  $end
$var wire     12 ,    o_data [11:0] $end
$var wire      1 -    o_overflow  $end
$var reg      12 F    o_data_w [11:0] $end
$var reg      12 G    o_data_r [11:0] $end
$var reg       1 H    o_valid_w $end
$var reg       1 I    o_valid_r $end
$var reg       1 J    o_overflow_w $end
$var reg       1 K    o_overflow_r $end
$var reg      12 L    abs_a_r [11:0] $end
$var reg      12 M    abs_b_r [11:0] $end
$var reg      13 N    mean_r [12:0] $end
$var reg      13 O    sum_r [12:0] $end
$var reg      13 P    diff_r [12:0] $end
$var reg      24 Q    mult_result_r [23:0] $end
$var reg      24 R    mac_mult_result_r [23:0] $end
$var reg      24 S    fixed_format_r [23:0] $end
$var reg      24 T    mac_fixed_format_r [23:0] $end
$var reg      25 U    prev_accumulator_r [24:0] $end
$var reg      25 V    accumulator_r [24:0] $end
$var reg      25 W    rounded_r [24:0] $end
$var reg      25 X    mac_rounded_r [24:0] $end
$upscope $end

$upscope $end

$enddefinitions $end
$dumpvars
b1100 $
b11 #
b101 "
b111 !
0%
1&
0'
b0 (
b0 )
b0 *
x+
bx ,
x-
b0 .
b0 /
b0 0
b11000011000001000011001100 1
b11111101001001000011001010 2
b11111100101101000011000000 3
b11000010010100111100010001 4
b11000010011010000010111010 5
b10011001110 6
b1001011 7
b101101011001 8
b1011100001000 9
b1101010000111 :
bx ;
bx <
bx =
x>
bx ?
0@
1A
0B
b0 C
b0 D
b0 E
bx F
bx G
0H
xI
0J
xK
bx L
bx M
bx N
bx O
bx P
bx Q
bx R
bx S
bx T
bx U
bx V
bx W
bx X
$end
#2500
0&
0A
b0 G
0K
0I
b0 U
0+
0-
b0 ,
#5000
1%
1@
#10000
0%
0@
#15000
1%
1@
#20000
0%
0@
#22500
1&
1A
#25000
1%
1@
#30000
0%
0@
bx G
bx U
bx ,
#35000
1%
1@
#40000
0%
1'
b11001100 (
b11000001 )
b11 *
b1 .
b11 E
b11000001 D
b11001100 C
1B
0@
b0 U
b1001100111001100 R
b1001100111011100 X
b10011001110 T
b10011001110 V
b10011001110 F
1H
b10011001110 G
1I
b10011001110 U
0H
b0 U
1H
1+
b10011001110 ,
#45000
1%
1@
#50000
0%
b11001100 ;
b11000001 <
b11 =
0>
b10011001110 ?
b1 /
b11001010 (
b111101001001 )
b10 .
b111101001001 D
b11001010 C
0@
0H
b111111110110111110011010 R
b111111110110111110101010 X
b11111101101111101 T
b11111101101111101 V
b101101111101 F
1H
1J
b101101111101 G
1K
b11111101101111101 U
0H
0J
b0 U
1H
1J
1-
b101101111101 ,
#55000
1%
1@
#60000
0%
b11001010 ;
b111101001001 <
b1001011 ?
b1 0
b10 /
b11000000 (
b111100101101 )
b11 .
b111100101101 D
b11000000 C
0@
0H
0J
b111111110110000111000000 R
b111111110110000111010000 X
b11111101100001110 T
b11111101100001110 V
b101100001110 F
1H
1J
b101100001110 G
b11111101100001110 U
0H
0J
b0 U
1H
1J
b101100001110 ,
#65000
1%
1@
#70000
0%
b11000000 ;
b111100101101 <
b101101011001 ?
b10 0
b11 /
b111100010001 (
b10010100 )
b100 .
b10010100 D
b111100010001 C
0@
0H
0J
b111111110111010111010100 R
b111111110111010111100100 X
b11111101110101111 T
b11111101110101111 V
b101110101111 F
1H
1J
b101110101111 G
b11111101110101111 U
0H
0J
b0 U
1H
1J
b101110101111 ,
#75000
1%
1@
#80000
0%
b111100010001 ;
b10010100 <
1>
b11100001000 ?
b100 /
b10111010 (
b10011010 )
b101 .
b10011010 D
b10111010 C
0@
0H
0J
b110111111100100 R
b110111111110100 X
b1101111111 T
b1101111111 V
b1101111111 F
1H
b1101111111 G
0K
b1101111111 U
0H
b0 U
1H
0-
b1101111111 ,
#85000
1%
1@
#90000
0%
b10111010 ;
b10011010 <
b101010000111 ?
b11 0
b101 /
0'
0B
0@
0H
0I
b1101111111 U
0+
#95000
1%
1@
#100000
0%
0@
#105000
1%
1@
#110000
